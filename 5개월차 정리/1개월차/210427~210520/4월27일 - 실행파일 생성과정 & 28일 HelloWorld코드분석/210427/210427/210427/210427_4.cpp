#include "stdafx.h"


using namespace std;

void main()
{
	// 음의 정수 표현 방법
	// 맨 왼쪽에 있는 비트가 0(부호비트)가 아닌 1로 만든다.
	// 단순히 부호비트만 바꾼다 해도 음수에서 양수 & 양수에서 음수로 바뀌지 않는다.
	
	// 양수에서 음수로 바꾸기
	/*
	  1  0001
	  -1 1001
	  -----------
	  0  1010 = 0이 아니다 0000

	*/

	// 음수에서 양수로 양수에서 음수로 바꾸는 방법
	// 2의 보수를 취한다

	// 2의 보수란?
	// 1의 보수를 취한 값에 + 1
	// 1의 보수란??
	// 비트 반전 

	// 0을 1로 , 1을 0으로 바꾸는게 비트반전

	/*
	            1의 보수   2의보수
		1  0001  1110  +1 =  1111
		-1 1111 
	-----------------------------------
	    0  0000
	*/


	// 실수 자료형의 표현 방식

	// 1. 고점 소수점 방식
	// 정수부와 소수부로 나뉠수 있다.
	// 1비트 = 부호 15비트 정수부 16비트 소수부
	// 단 15비트로 표현하는 것은 부호
	// 그래서 부동 소수점 방식이 생김
	// 단점 = 표현점이 부족

	// 2. 부동 소수점 방식
	// 하나의 실수를 가수부(m)의 저수부(e)로 나뉘어 표현
	// 00123일때 우리가 읽는 부분은 123이다. 이것은 소수점 위치마다 값이 달라진다.

	// 부동 소수점의 단점 = 오차 

	// 부동 소수점의 오차 확인방법
	//float a = 0.1f;  

	//
	//// for 문을 사용해 i를 가 100보다 작을시 i를 100번 증가 시킨다.
	//for (int i = 0.1; i < 100; ++i)
	//	a += 0.1; // a를 0.1씩 누적시켜 100번증가 시킨다.

	//// a의 대한 오차범위를 출력
	//printf("a:%f|n", a); 



	// 이스케이프 문자열 
	// 형태는 문자열 이지만 단일 문자로 취급한다.

	// \n(개행), |t(탭), |0 (NULL)
	
	// 출력 방법
	/*cout << "|n";
	cout << '|t';
     */


	// char 자료형은 정수 자료형 단 출력시 해당 정수가 의미하는 문자로 출력해준다.
	// 정수값을 저장하고 해당 정수가 어떤 문자로 의미하는지 해당 정수로 표현
	
	// 65라는 숫자의 정수 저장 
	//char a = 65; 
	//char b = 'A';

	//// 정수 65라는 숫자에 단일 문자 'A'가 저장 된다.
	//cout << "a:" << a << endl;
	//cout << "b:" << b << endl;

	
	// 아스키 코드를 사용한 Hello 출력
	// char A에 정수 값만 저장하고 b에 정수값만 저장 하는 형식
	// char로 선언한 자료형 중복 출력 가능 하다 

	//char a = 72, b = 101, c = 108, d = 111;

	//cout << a << b << c << c << d << endl;


	// 아스키 코드란?

	// 0에서 127까지 총 128개 (7bite)를 사용한다.
	// 1bite는 페리티 비트로서 통신 오류 검출을 위해 사용한다.
	
	// 페리티 비트를 제외한 7bite로는 영문 키보드로 담을수 있는 모든 가능성을 담았다.
	// 다만 영어권이 아니 국가에서는 언어를 표현할 수 없다.
	
	// 그래서 페리티 비트 또한 포함 한 아스키 코드가 등장.
    // -> 이를 ANSI 라고 부르는 사람도 있다.

    // 하지만, 여전히 표현할 수 없는 언어도 있다(한국어 등);
    // -> 한국 ,중국 , 일본 등 아시아 국가에서는 언어에 제한이 있다.
    // 그래서 등장한 전세계 공용 문자를 표현 가능한 유니코드가 탄생하게 된다.


    // 상수란?
    // 변하지않고 고정된 수를 상수
    // 자료형 앞에 const를 붙여주면 해당 변수는 상수가 된다. 
    // 단 const를 사용해 상수화를 시키면 선언과 동시에 초기화 진행 

    // const int a = 10;	

	//cout << "a:" << a << endl;

	//// 선언과 동시에 초기화가 진행되기 떄문에 또다시 초기화를 진행할수 없다.
	//a = 999;
	//
	//cout << "a:" << a << endl;


   // 리터럴 상수 = 문자 그대로의 고정된 상수
   // 문자 그대로의 상수를 리터럴 상수
   // 3,5 같은 숫자들
   // 임시 메모리 공간에 예약하고 3이라는 숫자를 저장한다. 임시 메모리 공간에 4라는 숫자를 저장하고 끄집어 와서 더해준다.
   // 더한 7또한 임시메모리에 저장 

   // 저장시 모든 byte를 저장가능하고 그중 4byte를 저장한다. int는 4byte이니까 예약해서 등록한다. 
   
   // 3과 4는 리터럴 상수이다.
   // 3과 4의 더하기 연산 수행장소는 cpu가 진행하지만 cpu는 메모리에 등록된 정보를 토대로 임무를 수행 
   // 그래서 3과 4를 메모리에 등록한다.
   // -> 이때 등록시키는 메모리는 임시 메모리에도 등록된다.
   
   // -> 임시메모리에 등록된 데이터는 코드라인을 벗어나는 즉시 소멸 
   // 임시메모리에 3과 4를 등록하기 위해 공간을 예약해야 하는데 과연 얼마만큼 공간을 예약할까?
   // -> 임시메모리에 등록된 데이터가 정수형 이라면 기본 int형으로 간주한다.

   // 예) int a = 3 + 4; // 12byte;  = 3 + 4 결과인 7 

  
   // float 에는 왜 f 가 붙을까? 
   // 임시 메모리에 정수 등록시 기본 int형으로 간주
   // 임시 메모리에 실수가 등록되면?? = 기본 double형으로 간주

   // a는 4bytes라는 메모리 공간을 예약하고 저장할 준비
   // 3.14는 임시메모리 공간에 8byte 공간만큼 등록
   // 8byte 에서 4byte로 저장할 경우 데이터 손상이 발생한다.
   
   // 8byte환경에서 a 를 4byte로 저장하기 떄문에 오류가 발생함
   //예) float a = 3.14;
 
    
   // f키워드는 임시메모리 공간에 4byte 만큼 예약해서 등록한다.
   // 4byte공간에 4byte로 복사할경우 데이터 손실이 발생하지 않는다.
   // 예) float a = 3.14f;



}