#include <iostream>

using namespace std;

void main()
{
	//// 2차원 배열의 이름
	//// 배열이 할당된 메모리의 시작 주소와 같다!
	//int		iArr[2][3] = { 1, 2, 3, 4, 5, 6 };

	//cout << "iArr: " << iArr << endl;
	//cout << "---------------------------" << endl;
	//for (int i = 0; i < 2; ++i)
	//{
	//	for (int j = 0; j < 3; ++j)
	//		cout << &iArr[i][j] << endl;
	//}


	//// 2차원 배열의 이름은 2차원 배열이 할당된 메모리의 시작 주소이다.
	//// 포인터에 역참조 연산자를 사용하면 해당 메모리에 저장된 값이 나오게 된다.
	//// 2차원 배열은 원소로 1차원 배열을 가진다.
	//int		iArr[2][3] = { 1, 2, 3, 4, 5, 6 };

	//// 2차원 배열의 시작 주소
	//cout << "iArr: " << iArr << endl;

	//// 2차원 배열의 첫 번째 원소의 값 == 1차원 배열
	//// -> 1차원 배열을 단순히 출력하면 주소가 나온다!
	//cout << "*iArr: " << *iArr << endl;

	//cout << "**iArr: " << **iArr << endl;


	//// 2차원 배열의 주소값 저장하기
	//// 포인터 연산 시 증가 값이 다르다!
	//// 포인터 연산 시 증가 값은 자료형의 크기만큼 증가한다.
	//int		iArr[2][3] = { 1, 2, 3, 4, 5, 6 };
	//int**	ptr = iArr;		// 불가능


	//// 2차원 배열의 포인터 연산은 원소의 크기(1차원 배열) 만큼 증가한다.
	//// -> 12bytes만큼 증가한다.
	//int		iArr[2][3] = { 1, 2, 3, 4, 5, 6 };
	//cout << "(iArr + 0): " << (iArr + 0) << endl;
	//cout << "(iArr + 1): " << (iArr + 1) << endl;


	//// 이중 포인터의 포인터 연산은 포인터크기만큼 증가한다.
	//// -> 4bytes만큼 증가한다.
	//int**		ptr;
	//ptr + 1;

	// 결국 2차원 배열의 포인터형은 이중 포인터가 아니다!


	// 2차원 배열의 포인터형
	/*
	자료형(*변수명)[열(가로)]
	*/
	int		iArr[2][3] = { 1, 2, 3, 4, 5, 6 };
	int(*ptr)[3] = iArr;


}